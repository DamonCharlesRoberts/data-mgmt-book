# Common programming tools, their benefits and drawbacks

Those performing quantitative analyses on data have a wide number of options for tools available to them. I assume that the readers of this book are either reading this book while learning about their first statistical programming language or are already familiar with at least one. When choosing our tools, we often use whatever we are told to learn. Either we are a student that is tasked with learning the statistical programming language `R` or perhaps even `Python`. We may also be an academic researcher who has been doing quantitative analyses for years with `R` and we have done so since graduate school because we were told that our academic discipline was going that way. The tools that we learn and use are still options, however.

Each tool I discuss in the book have an origin in trying to address some sort of need. For example, `Python` is one of the most popular programming languages in the world. Despite this, it is one of the most used languages by data scientists. Data scientists by no means make up the bulk of those who are professional programmers. `Python` is a general-use programming language that is designed to be accessible for those who want to do things like statistical analysis, web-design, and web application and software engineering. That is, it is a general use programming language. `R` and `Julia` are programming languages like `Python` in that they are designed to be highly accessible. They are designed, however, to be useful specifically for statistical analysis and reporting. Their intended use is a bit more narrow -- though, you can probably find examples of people using both languages for other things besides statistical analysis.

These examples illustrate an important point at the heart of this book: while there are plenty of options and people will use all of the tools I will discuss in this chapter to do data management and pre-processing, it does not necessarily mean that the tool is a "great" or even "good" option for these tasks. In many cases, a particular tool I will provide an example with in the book is a "good-enough" option that can work. This is because each of these tools are created with an original purpose in mind. One of the best ways to determine whether or not a tool is appropriate for the task at hand is to ask yourself, "did this tool eventually get this functionality, or was it designed with it?" If the particular tool eventually included that functionality, then it is a tool that is "good-enough" for that task. If the tool was designed with the functionality you need from it, then it is probably a "good" or "great" tool. I will make mention of these tools and what their purposes are by the tools' creators as I introduce them throughout the chapter.

I am a realist though. Many of us are balancing our limited attention, time, and energy to do quantitative analysis. We often have deadlines we are facing and have to go with what is "good-enough." The spirit of the book is not judge or chastise people for the tools that they choose to use, but to give them the opportunity to truly choose their tool rather than to use what they thought they had to use. The hope is that the book will give you the information needed to make the choice between whatever tradeoffs you face with using these tools an easy choice. If you choose to change things up, even if it is reluctantly, then the hope is to provide you something to reference to make that change easier!

## An aside about efficiency, readability, and replicability

At the outset of the book, I kept mentioning the "efficiency, readability, and replicability" as being important features or a programming language. Here, I want to elaborate upon what I mean by these terms.

The first feature is efficiency. When we think of efficiency, we may think of how much effort is being put into a task relative to how much is accomplished by completing the task. That is what we mean here too. While there are some really technical rabbit holes one may fall into among computer scientists when defining the efficiency of one's code and various metrics that we can calculate to quantify efficiency, when I refer to efficiency, all I am referring to is, "how much work is your computer putting in relative to the task?" For example, if it takes 20 seconds for a program we wrote on our computer to evaluate the expression `2+2`, then we would say that is pretty inefficient relative to me just doing it in my head. In that case, we would say that our program is pretty inefficient.

When thinking about efficiency, there are more ways to measure than the time elapsed to calculate it like in my example of evaluating the expression `2+2` -- though this is perhaps one of the most common ways efficiency is measured. We can also think of it as how much memory our computer must commit to using. When purchasing a computer, you may hear someone discuss the `RAM` of the computer. While `RAM` is one type of memory, it is distinct from the Hard Drive on your computer that stores your files and software on it. One way that we can think of the `RAM` is the stuff that you have asked your computer to keep track of at any given point in time. `RAM` is active memory. Let me illustrate this through an analogy. You have probably memorized your phone number. Now say that I ask you to enter your phone number while I am also asking you to keep track of my phone number as I read it out loud to you. This is probably a lot to keep track of. You are not only being asked to keep track of 18 numbers all at once, but also the order in which those numbers appear and to keep track of which one is yours and which one is mine. This task might be hard. If you don't believe me, try it with a friend. The `RAM` simply refers to the amount of stuff you are asking your computer to keep track of and readily accessible within a split second. It is the calendar events, it is the web pages you have open on your browser, it is the contents of the song that you are playing, etc. The files that are currently closed on your computer are stored on your hard drive and you are not necessarily asking your computer to have that information readily accessible in a split second, not until you open that file, at least. While this is an oversimplification, `RAM` is another common metric that people think of when thinking about the efficiency of a program. If the program has **tons** of information stored in it, it will significantly slow down your computer as it is struggling to keep up with all of the things you are asking it to do -- just like it would slow you down to enter your phone number while I'm reading out my own to you at the same time.

We want the evaluation of our code for our data management and pre-processing to be both quick and not too laborious for our computer to do. If we use code that is inefficient, it will take longer for us to be able to complete these tasks. Additionally, if we have a computer with more `RAM` and it works on our computer, it may not work on someone elses that has less `RAM`, or at least it will take much longer for them than it would for us. This is an issue I will come back to in a few paragraphs.

Another important feature of a programming language and of our own code is the readability of it. In an ideal world, our code should be understandable even to those that are not familiar with the coding language we are using. One of the primary reasons in a research setting will be discussed shortly, but otherwise it makes it easier for us to detect errors in our code! If our code takes a lot of effort to understand what it is doing, then it will undoubtedly make it more difficult for us to catch a mistake that we have made. We want our code easy to understand so that we can catch our mistakes as well as others'. Now, we often do not have the luxury of jumping into any coding language and immediately understand what that code is doing, so it is often far-fetched to say that it should be readable to those who have no experience with the language, but we should still make it reasonably easy to get a sense of what is going on for everyone and super clear what is happening to those that are familiar with the language.

Reproducibility is the last key feature that we should consider about code. I have hinted to it a few times. Reproducibility is a challenging but important endeavor for every research project that we work on. Reproducibility refers to the idea that anyone can take our documentation, repeat what we did, and be able to get the same results (or at least come to similar conclusions). How can we achieve reproducibility? Well, this is a topic that is still debated. But in general, we want the steps we take when managing and pre-processing our data to be something that someone else can follow relatively easily. Meaning that the documentation we have is accurate, our code is efficient so almost anyone can do it regardless of their particular computer's hardware, and that it is readable so that as many people as possible can understand the steps we took during the project.

Later in this chapter, I will be evaluating the programming languages and common libraries used for data management and pre-processing on these three key features. It is important to note that these languages and libraries are not deterministically good or bad at achieving these goals. Often the person writing the code is at fault for writing inefficient, unreadable, and unreproducible code. However, there is no one "right" way to do anything. However, there are some programming languages and libraries that do not do much to encourage efficient, readable, and reproducible code. So, my evaluation of these languages and libraries on these features will be limited to their capacity to encourage the programmer to produce code that contains these features.

## What is a library?

Before, I move on, it is important to provide a brief explanation of how many of these programming languages that you are about to learn work. Most of these languages are referred to as object-oriented programming languages (`OOP`). What this means is that we can store the results of some task in something called an `object`. So, say for example that I wan to evaluate the expression, `2+2`. Once I have successfully determined that the result of the expression is `4`, I may want to store that result for later. In an `OOP`, I can store the result, `4`, in an `object`. Now, say that I won't always be adding `2` and `2`, but I may instead be adding `2` and `3` or `10` and `2`. Instead, I want to quickly be able to evaluate a summative expression and be able to just plug in those numbers when I need to rather than have to keep rewriting `a+b`. This is a perfect candidate for a `function`. A function is just a piece of code that takes a pre-specified set of parameters, such as what integer `a` and `b` represent, and perform some task using those parameters. I can store the function to evaluate the summative expression of `a+b` and just pass in the integers that represent `a` and `b`, such as `a = 2` and `b = 2`. `OOP` allows me to store this function as an object just like I would the result of `2+2`. If you are still not quite sure what this looks like in practice, don't worry, you'll see later in the chapter!

So, a function is some chunk of code that we can name and store as an object so that we do not have to reinvent the wheel over and over. While in the previous example of a function that does `a+b`, this may seem relatively not hard to do, but sometimes we have tasks that are extremely complex and take a lot of code to complete. So, functions represent stored code that take our parameters as an input, does something to that input, and then returns some output. This is illustrated in @fig-function-visual below.

```{mermaid}
%%| label: fig-function-visual
%%| fig-cap: Visualizing a function
%%| fig-width: 6.5
%%{init: {'theme':'base', 'themeVariables':{'primaryColor':'#ffffff', 'primaryBorderColor': '#000000'}}}%%
graph LR;
A["Input: <br/> a = 2, b = 2"] --> B["Function: <br/> a+b <br/> 2+2"]
B --> C["Output: <br/> 4"]
```

Since we can save a function as an object thanks to `OOP`, we can store this object in what is called a library. A library refers to a collection of functions which all contain code designed to complete specific tasks. So for example, I can create an object storing the function depicted in @fig-function-visual to evaluate a summative expression as `addition`. I can create another object that stores the function to evaluate a differencing expression as `subtraction`. I can put these two objects in a library, as depicted in @fig-library, and post them to a specialized website for others to download the library so that they can easily download those functions and easily use those functions without having to write their own functions or code.

```{mermaid}
%%| label: fig-library
%%| fig-cap: Visualizing a library of functions
%%| fig-width: 6.5
%%{init: {'theme':'base', 'themeVariables':{'primaryColor':'#ffffff', 'primaryBorderColor': '#000000'}}}%%
graph TD;
A[library] --> B["Input: <br/> a = 2, b = 2"] 
B --> C["Addition function: <br/> a+b <br/> 2+2"]
C --> D["Output: <br/> 4"]
B --> E["Subtraction function: <br/> a-b <br/> 2-2"]
E --> F["Output: <br/> 0"]
```

In essence, libraries are just large files of code that someone else has written that let you use a particular function defined in that code so that you only need to provide some inputs (or arguments is what they are often called), the code does something to those inputs, and then it produces some output.

How is all of this relevant to data management and pre-processing? As I mentioned, most of the languages that we are using here are `OOP`. Most of the time, we do not have to write our own code from scratch to manage or pre-process our data. We will have to write some code, but we are often interacting with functions that someone else has written and put together in a library for us to make our code much shorter. As these functions are written by others and we often are heavily dependent on functions from a library that someone else has written, we should and cannot blindly rely on functions or libraries. We should not always assume that they are efficient, readable, nor enable reproducible code. Just because a programming language enables these features in our code, our experience with this is heavily dependent on the particular libraries that we choose to use within a particular programming language. That is why, in the next section and the book at large, I will be putting a lot of emphasis on the common packages people use within each of these programming languages to pre-process and manage their data.

## Programming language options, setup, and comparisons

To re-iterate, there is no one absolute better programming language for someone to use to pre-process and manage their data. However, this book will focus on emphasizing and advocating for programming languages that are efficient, readable, and reproducible. The options that I include here are not comprehensive. One primary reason for a programming language to be excluded is due to it requiring a license to use. One popular software in the social sciences is `STATA`. While the programming language is not proprietary, you can only use `STATA` as a programming language in their proprietary software, and is therefore not reproducible. As a result, `STATA` is not discussed as an option in this book, though it is popular.

Before, jumping into the installation and beginning to interact with the particular programming languages, I want to discuss the difference between installing the software for your computer to understand the language and the installation of the Interactive Developer's Environment (`IDE`) that provides nifty features to not just write the files but to interact with the code such as running the code in parts rather than as the whole file, debugging tools, and other features.

These coding languages do not come standard on our computers. We have to install software that links the code already on our computer that it understands (often C++). This is the first thing we will need to download. Often this software will come with extremely basic `IDEs` that we can use to write code, save files that store the code, and run code, as either complete files or as smaller pieces of code such as a single line (interactively). These `IDEs` are often extremely basic and include really limited functionality. So the second think we often download is a more fully-fledged `IDE`.^[Also, for those interested, you can forego `IDEs` altogether and install a text editor such as `neovim`. While these are extremely customizable, they require quite a lot of comfort and sophistication with command line interfaces and require a lot of work to get them to a point where you can be semi-productive with them.] Some programs have their own popular `IDEs` such as `R` with `RStudio`. However, in the spirit of not being beholden to a single coding language for all tasks, I'll provide instructions on how to install a really popular do-it-all `IDE` called Visual Studio Code (`VSCode`). `VSCode` has extensions that enable you to be able to fully interact with all of these coding languages discussed below.

### Installing an IDE, `VSCode`

Again, if you want to install RStudio or some other language specific `IDE`, that is totally up to you! Here, in this book I will cover how to install an `IDE` that works for all of the languages in this book.

First, go to [https://code.visualstudio.com/download](https://code.visualstudio.com/download). Then you will want to choose an installation that is appropriate for your operating system. Unless you are wanting to do some custom installation, you should choose the button just under the icon for the type of operating system that you use. You can then follow the standard installation steps you take to install software on your computer. You should not need to change any of the defaults to install `VSCode` on your system.

Once successfully installed, then we can move onto installing the particular coding languages.

### `R`

`R` is an extremely popular coding language for statistical analysis among academics, analysts, and for a decent proportion of data scientists. There are a number of reasons for its appeal but chief among them is the robust community to help with the reporting of statistical analyses. Unlike some of the other option discussed below, `R` has a large number of options for packages that help with generating tables and figures for the results of complicated statistical analyses. This is not to say that the other programming languages do not have any support for data visualization and reporting, but rather that there are more options for popular types of data visualization and reporting in the scientific community. This makes it really popular among academics.

#### Installation

Installation of R is quite straightforward. The first thing that we will want to do is navigate to the `CRAN` website at [https://cran.r-project.org](https://cran.r-project.org). This website is the "Comprehensive R Archive Network" and is the default place that we not only install `R`, but we can often find and install many of the libraries (often referred to as packages by `R` users).

Once on the webpage, we will want to follow the link to "Download R for" the operating system that we are using. So if you are using a Mac, then you will want to follow the link to the "Download R for macOS". Once clicking on the link, it will take you to a page listing different releases of R. You will want to follow the most recent one. At the time of writing this book, that would be `R version 4.3.1`. 

:::{.callout-note}
# For macOS users

If you are installing `R` on a Mac, you cannot install any package of `R`. If you are using one of the newer Apple Silicon chips, then you should install the `R` package made for those using Apple silicon chips and not for Intel. For example, if you are trying to install `R` version 4.3.1, then you should follow the link `R-4.3.1-arm64.pkg` If you are using a Mac that has an Intel chip, then you should choose `R-4.3.1-x86_64.pkg`.
:::

Once you have clicked on the link, you should follow the normal steps you take to install software on your computer. You should not need to make any customizations to the installation (such as installation destination).

#### Setting up `VSCode` with `R`

If you want to use `R` with `VSCode`, getting them to work together is pretty straight forward! You will want to install an extension that enables `VSCode` to recognize `R` code and to know what to do with it when you run your `R` code. While you can install extensions directly in `VSCode`, we will go to [https://marketplace.visualstudio.com/VSCode](https://marketplace.visualstudio.com/VSCode). Once there, we can search "R". What should be the first option is an extension to work with `R` in `VSCode`. We can install that extension by clicking the "Install button". 

Once installed, you may not be quite ready to run `R` in `VSCode` just yet. You should follow the steps in the "Getting Started" section of the page that you downloaded the extension from and view the extension's documentation for any extra requirements they may have for you to start running your `R` code in `VSCode`.

### Illustration of `OOP` in `R`

Going back to the discussion above about `OOP`, functions, and libraries in `R`. Here is some simple code to help give you an understanding of how `R` works. To follow along, you can open `VSCocde` and then create a new file called `my_first_r_file.R`. Since you are specifying that the file is an `R` file with the extension `.R`, `VSCode` will now expect to only see `R` code in that file.

First, let me make a comment about comments in R! You should always add comments to your code. This helps with the readability and reproducibility of your code. Comments are incredibly useful in that they allow you to explain what your code is doing and can act as really useful documentation.

To make a comment in `R`, you can simply put the hash or pound symbol at the start of any line in your `R` file. Then you can write freely. There are no requirements for what words you use or how you structure your sentences for lines when you've put a comment in front of them. For example:

```{r}
#| label: r-comments
#| eval: false
#| echo: true
# This is a comment in R
# Any characters that you place after a "#"
# Will not be evaluated as code.
```

Now, let's evaluate my simple expression from above with `R`:

```{r}
#| label: r-addition
#| eval: true
#| echo: true
2+2 # add 2 and 2 together
```

Once we have written this code, we can highlight the code and click the play button (sideways triangle) at the top. This will run the code. Another option is to use the keyboard shortcut "CMD/CTRL + RETURN/ENTER". This will open our `R` console at the bottom of our screen. The console is responsible for taking the code passed from our `R` file and actually doing the evaluation of it.

We should see that the output is `4`. Great, that is exactly what we should expect. 

Now, let's say that we want to take the result from this expression and use it later such as by doing `2+2+2`. Rather than typing out `2+2+2`, we can take advantage of the fact that `R` is an `OOP` language and store the result of our original expression into an object that I will call "result". The `<-` is called an assignment operator in R and it is used specifically for assigning the result of some expression to an object. Other programming languages that we encounter will use often just use `=` as the assignment operator. 

Once I have created the "result" object, I will then take the object that I called "result" and will add two to it, then store that result into an object called "result_two". I can then see the value stored in "result_two" by using a function called print. We should expect that the result is `6` if everything worked correctly.

```{r}
#| label: r-objects
#| eval: true
#| echo: true
result <- 2+2 # add 2 and 2 together, store it into an object called result
result_two <- result + 2 # add 2 to result, store it into an object called result_two
print(result_two) # show me the value of result_two
```

I'm not limited to adding a bunch of 2's together in R. What if, I want to do what I did above but with other numbers and don't want to continuously repeat myself. Well I can write a function and store that function to an object so that I can just reuse the same code over and over again.

So, I am going to write a function that I am going to call "addition." This function will take two inputs that I am going to call `a` and `b`. These inputs can be any two integers that I want. Once I have provided the basic information about my function to `R`, I'll specify what I want the function to do with those inputs in the main block within the curly brackets. As you can see, I want to add `a` and `b` together and store it in a local object called `temp_result`. I will then `return` the the `result`. 

```{r}
#| label: r-addition-fxn
#| eval: false
#| echo: true
addition <- function(a = 1, b = 1) {
  temp_result <- a + b
  return(temp_result)
}
```

So once I have defined this function, I can start using it!

```{r}
#| label: r-addition-result
#| eval: false
#| echo: true
result <- addition(a = 2, b = 2)
print(result)
result <- addition(a = 10, b = 10)
print(result)
```

There are plenty of subtleties in the code here that I won't go over as they are beyond the scope of the book. There are plenty of excellent discussions out there about `OOP` in `R` if you want to delve more into getting comfortable with writing functions in `R`. But, the main idea is that you can see that I can take the `addition` object as a function to reuse the code within the curly brackets to apply it to different inputs.

As discussed before, there are plenty of functions that we might write that could be useful to share with others. To do this, we can take these functions and put them in a `library` and upload it to `CRAN`. Details about how to do this are also outside of the scope of this book, but thankfully there are plenty of great resources on how to do this too!

`R` comes with a `base-r` library of functions that cover bare minimum needs for the users to work with the language. For example, we have already used multiple functions in the code above. For example, `print` took an input from us -- our object `result`, did something with it, and then printed out the value of our object. While the way that the `print` function knew to print out the value of `4` rather than to just print out "result" in our console is a whole other discussion about a concept called pointers that are also beyond the scope of the book, the `print` function had some underlying code that knew that `result` was an object and we wanted to print out the value that `result` represented.

So, how can I access a library that someone else has written? It isn't too bad! There is a function that comes standard with `R`, in the `base-r` library, that allows us to access libraries uploaded to `CRAN`: `install.packages()`. With `install.packages()` all that we have to do is specify the name of the library we want to install, then we can run it. 

:::{.callout-note}
# How do I know the name of a library or whether a function exists?

There is no one way that this happens. I often stumble across useful libraries and functions within those libraries in different places of the internet, from talking with others, etc. As you go along, you'll begin to get more comfortable finding out these things yourself.

:::

### Common libraries in R for data management and pre-processing

#### The dominance of the Tidyverse

#### For data management

##### readxl

##### haven

##### rjson

##### db

##### duckdb

#### For data pre-processing

##### base-r

##### Tidyverse

##### data.table

##### polars

### `Python`

#### Installation

https://www.python.org/downloads/

### `Julia`

https://julialang.org/downloads/#download_julia